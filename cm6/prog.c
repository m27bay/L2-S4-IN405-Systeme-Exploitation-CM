#include <stdio.h>
#include <stdlib.h>

#include <wait.h>
#include <unistd.h>

#include <errno.h>

// for INT_MAW et INT_MIN
#include <limits.h>

/**
  * Cours:
  * Ordonnanceur: Gère accès au processeur, via un algo
  * algo plus au moins efficace
  * Quand ordonnancer: changement d'etat d'un processus
  * ex: creation new processus/ terminaison processus/
  * attente de ressource/ ect
  *
  * Type algo:
  * FIFO problème: sleep x heure on peut rien faire
  *
  * shortest job first: plus rapide executer
  * faut connaitre le temps d'execution avant
  * on peut avoir des fonctions tests avec un temps
  * d'execution peu variable
  *
  * round-robin: chaque processus se lance pendant un temps x
  * et peut se mettre en pause si non fini puis il est remis
  * dans la fils d'attende
  *
  * tirage au sort:
  *
  * Ajout d'une priorité:
  * man nice/ man 2 nice permet de donner une valeur
  * d'importance
  * Une file d'attente par priorité (entre -20 et 19)
  * Plus la valeur est haute moins elle est importante
  */

/*
void create_children(const int num_children) {
  if(!num_children) {
    printf("'num_children': invalid");
    exit(EXIT_FAILURE);
  }

  for(int child=0; child<num_children; child++) {
    if(!fork())
      break;
    wait(NULL);
  }

  printf("PID: %d\n", (int)getpid());
}
*/

/*
void algo_fifo(struct process *pids, const int n_pids) {
  int current_date = 0, i;

  while(1) {
    int min_arrival = INT_MAX, min_i = -1;

    for(int i=0; i<n_pids; ++i) {

      if(pids[i].exec_time  ==  pids[i].elapsed_time)
        continue; // Pass at the next iteration

      if(min_arrival > pids[i].arrival_time) {
        min_arrival = pids[i].arrival_time;
        min_i = i;
      }
    }

    if(min_i  <  0)
      break;

    current_date = MAX(current_date, pids[min_i].arrival_time);
    _exec_process_(pids + min_i, &current_date, pids[min_i].exec_time);
    sleep(1);
  }
}


void algo_sjf(struct process *pids, const int n_pids) {
  int current_date = 0, i;

  while(1) {
    int min_arrival = INT_MAX, min_i = -1;
    int min_exec = INT_MAX;

    for(int i=0; i<n_pids; ++i) {

      if(pids[i].exec_time  ==  pids[i].elapsed_time)
        continue; // Pass at the next iteration

      if(min_exec  ==  INT_MAX  &&
        min_arrival > pids[i].arrival_time) {

        min_arrival = pids[i].arrival_time;
        min_i = i;
      }

      if(pids[i].arrival_time  <=  current_date  &&
        pids[i].exec_time  <  min_exec) {

        min_exec = pids[i].exec_time;
        min_i = i;
      }
    }

    if(min_i  <  0)
      break;

    current_date = MAX(current_date, pids[min_i].arrival_time);
    _exec_process_(pids + min_i, &current_date, pids[min_i].exec_time);
    sleep(1);
  }
}
*/

int main(int argc, char const *argv[])
{
  printf("Compile success\n\n");
  // create_children(10);
  return 0;
}
